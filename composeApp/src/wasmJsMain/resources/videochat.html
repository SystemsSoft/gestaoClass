<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Conferência WebRTC com P2P</title>
  <style>
    video {
      width: 30%;m
      border: 1px solid black;
      margin: 5px;
    }
  </style>
</head>
<body>
<h2>Conferência WebRTC</h2>
<input type="text" id="roomInput" placeholder="Nome da sala" />
<button id="joinBtn">Entrar na sala</button>
<div id="videos"></div>

<script>
  // ID interno usado apenas para WebRTC (não exibido)
  const myId = Math.random().toString(36).substring(2);

  const roomInput = document.getElementById("roomInput");
  const joinBtn = document.getElementById("joinBtn");
  const videosDiv = document.getElementById("videos");

  const peers = {};          // { peerId: RTCPeerConnection }
  const videoElements = {};  // { peerId: <video> }

  let localStream;
  let room;
  let ws;

  async function startLocalStream() {
    try {
      localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
      const video = document.createElement("video");
      video.autoplay = true;
      video.muted = true; // Para não causar eco e permitir autoplay
      video.srcObject = localStream;
      videosDiv.appendChild(video);
    } catch (err) {
      alert("Erro ao acessar câmera/microfone: " + err.message);
      console.error("Erro getUserMedia:", err);
      throw err; // para parar o fluxo de entrar na sala
    }
  }

  function addRemoteVideo(peerId, stream) {
    if (videoElements[peerId]) return; // vídeo já existe
    const video = document.createElement("video");
    video.autoplay = true;
    video.srcObject = stream;
    videoElements[peerId] = video;
    videosDiv.appendChild(video);
  }

  function removeRemoteVideo(peerId) {
    if (videoElements[peerId]) {
      videosDiv.removeChild(videoElements[peerId]);
      delete videoElements[peerId];
    }
  }

  function createPeer(peerId, isInitiator) {
    const pc = new RTCPeerConnection();

    // Envia candidatos ICE pelo WS
    pc.onicecandidate = event => {
      if (event.candidate) {
        send({
          type: "signal",
          to: peerId,
          from: myId,
          sala: room,
          payload: { type: "candidate", candidate: event.candidate }
        });
      }
    };

    // Recebe streams remotos e adiciona vídeo
    pc.ontrack = event => {
      addRemoteVideo(peerId, event.streams[0]);
    };

    pc.oniceconnectionstatechange = () => {
      console.log(`Estado ICE para ${peerId}:`, pc.iceConnectionState);
      if (pc.iceConnectionState === "failed" || pc.iceConnectionState === "disconnected") {
        alert(`Conexão com ${peerId} foi perdida.`);
        if (peers[peerId]) {
          peers[peerId].close();
          delete peers[peerId];
          removeRemoteVideo(peerId);
        }
      }
    };

    // Adiciona tracks do stream local para enviar ao peer
    localStream.getTracks().forEach(track => pc.addTrack(track, localStream));

    peers[peerId] = pc;

    if (isInitiator) {
      pc.createOffer()
        .then(offer => pc.setLocalDescription(offer))
        .then(() => {
          send({
            type: "signal",
            to: peerId,
            from: myId,
            sala: room,
            payload: pc.localDescription
          });
        })
        .catch(err => {
          alert("Erro ao criar oferta WebRTC: " + err.message);
          console.error(err);
        });
    }

    return pc;
  }

  function send(data) {
    if (!ws || ws.readyState !== WebSocket.OPEN) {
      alert("WebSocket não está conectado.");
      console.warn("Tentativa de enviar mensagem com WS fechado:", data);
      return;
    }
    ws.send(JSON.stringify(data));
  }

  joinBtn.onclick = async () => {
    room = roomInput.value.trim();
    if (!room) {
      alert("Informe o nome da sala.");
      return;
    }

    try {
      await startLocalStream();
    } catch {
      return; // se falhar ao acessar câmera/mic, aborta
    }

    ws = new WebSocket(`ws://${location.host}/signal`);

    ws.onerror = event => {
      alert("Erro na conexão WebSocket. Verifique o servidor.");
      console.error("WebSocket error:", event);
    };

    ws.onopen = () => {
      console.log("WebSocket conectado");
      send({ type: "join", id: myId, sala: room });
    };

    ws.onclose = () => {
      alert("Conexão WebSocket fechada.");
      console.warn("WebSocket fechado");
    };

    ws.onmessage = async (event) => {
      try {
        const msg = JSON.parse(event.data);

        if (msg.type === "peers") {
          // Peers já na sala, cria conexão como iniciador
          msg.peers.forEach(peerId => {
            createPeer(peerId, true);
          });
        }
        else if (msg.type === "new-peer") {
          // Novo peer entrou na sala, cria conexão mas não inicia oferta
          const peerId = msg.id;
          createPeer(peerId, false);
        }
        else if (msg.type === "signal") {
          const peerId = msg.from;
          let pc = peers[peerId];
          if (!pc) {
            pc = createPeer(peerId, false);
          }
          const payload = msg.payload;

          if (payload.type === "offer") {
            await pc.setRemoteDescription(new RTCSessionDescription(payload));
            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);
            send({
              type: "signal",
              to: peerId,
              from: myId,
              sala: room,
              payload: answer
            });
          } else if (payload.type === "answer") {
            await pc.setRemoteDescription(new RTCSessionDescription(payload));
          } else if (payload.type === "candidate") {
            if (payload.candidate) {
              await pc.addIceCandidate(new RTCIceCandidate(payload.candidate));
            }
          }
        }
        else if (msg.type === "peer-left") {
          const peerId = msg.id;
          if (peers[peerId]) {
            peers[peerId].close();
            delete peers[peerId];
          }
          removeRemoteVideo(peerId);
        }
      } catch (err) {
        alert("Erro ao processar mensagem do servidor: " + err.message);
        console.error("Erro onmessage:", err, event.data);
      }
    };
  };
</script>
</body>
</html>
